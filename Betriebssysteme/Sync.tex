\section*{Synchronisation}
\textbf{Race Conditions:} geteilte Ressource, Ergebnis abhänging von Ausführungsreihenfolge

\textbf{Kritische Abschnitte:} logisch ununterbrechbare Code-bereiche;

\textbf{Kriterien von Dijkstra: }
\begin{itemize}
\item  Keine zwei Prozesse gleichzeitig im gleichen kritischen Abschnitt (mutual exclusion)
\item  Keine Annahmen über die Geschwindigkeit, Anzahl der Prozesse bzw. Prozessoren
\item  Kein Blockieren durch Prozesse außerhalb eines kritischen Abschnittes
\item kein ewiges Warten (fairness condition)
\end{itemize}


Methoden:
\begin{itemize}
\item busy waiting/spinlock: testen einer Variablen bis zutritt erlaubt
\item interrupts maskieren: nur bei Einkernern, sehr ungünstig
\item Hardwareunterstützung durch atomare Befehle
\item Semaphore/Mutex
\begin{verbatim}
Semaphore x = new Semaphore();
x.Down(); // kritischer Abschnitt besetzt?
   c=counter.read(); // kritischer Abschnitt
   c++;
   counter.write(c);
x.Up();  // Verlassen des kritischen Abschnittes
\end{verbatim}

\item Erzeuger-Verbraucher
\begin{multicols}{2}
\begin{verbatim}
Erzeuger:
While (true) {
   produce(item);
   Down(frei);
   Down(mutex);
      putInBuffer(item);
   Up(mutex);
   Up(belegt);
}
Verbraucher:
While (true) {
   Down(belegt);
   Down(mutex);
      getFromBuffer(item);
   Up(mutex);
   Up(frei);
}
\end{verbatim}
\end{multicols}

\item Monitor: Ein Betriebsmittel aus Prozeduren und Daten, geshared zwischen Prozessen, aber nur von einem gleichzeitig nutzbar (bsp. synchronized in Java)

Methoden: Enter, Leave, Wait, Pulse

\end{itemize}
\section*{Deadlock}
Darstellung: Belegungsgraph; Prozess -> \fbox{Ressource}


\begin{tikzpicture}
%\node[ellipse](1){Prozess1} -- \node[rectangle](2){Ressource} -- \node[circle](3){Prozess2};
%\Edge(1)(2); \Edge(2)(3);

\end{tikzpicture}

Bedingungen: 
\begin{itemize}
\item Mutual exclusion: Ressourcensharing nicht möglich (DVD-Brenner)
\item Hold-and-wait: Prozesse belegen Ressourcen und wollen weitere
\item No preemption: Entzug nicht möglich
\item Circular waiting: gegenseitiges Warten
\end{itemize}

Strategien: 
\begin{itemize}
\item Ignorieren (wenn selten)
\item Erkennen und beheben (Erkennen: Zyklus im Belegungsgraph) :\\
Unterbrechung, Rollback Prozessabbruch Transaktionsabbruch
\item Dynamisches Verhindern: notwendig Vorwissen über Bedarf \\
z.B. Bankiers-Algorithmus: prüfen, ob es eine Zuteilungsreihefolge gibt, bei der der Bedarf erfüllt werden kann

\item Vermeiden: vermeiden einer der Deadlock-Bedingungen
\begin{itemize}
\item Mutual exclusion: z.B. virtualisieren mit Spooling
\item Hold-and-wait: anfordern aller benötigten Ressourcen auf einen Schlag, oder freigabe alter Ressourcen bevor weitere Angefordert werden
\item Circular waiting: nummerieren der Ressourcen, anforderung nur in aufsteigender Reihenfolge\\
z.B. in Echtzeitsysteme: Priority Ceiling Protocol\\
Ressource hat Ceiling Priorität = maximale Priorität der Tasks, die sie verwenden werden. Der sie nutzende Task hat während der Nutzung diese Priorität
\end{itemize}
\end{itemize}
\section*{Kommunikation}
\textbf{Nachrichten:} verbindungsorientiert vs verbindungslos, Synchron(Blockierend) vs Asynchron

\textbf{Speicher:} gemeinsamer Adressraum (Threads), Shared Memory, Datei (Prozess)

\subsection*{Interprozesskommunikation}
\begin{itemize}
\item Pipes und FIFOs (Named Pipes) als Nachrichtenkanal
\item Nachrichtenwarteschlangen (Message Queues)
\item Gemeinsam genutzter Speicher (Shared Memory)
\item Sockets (Ip-Loopback)
\end{itemize}

\subsubsection*{Pipes}
Unidirektional, bidirektional über mehrere Pipes; Standardausgabe zu Standardeingabe

\begin{verbatim}
int fds[2] / Filedescriptoren für Pipe
pipe(fds);
if (fork() == 0) {
   // 1. Kindprozess, Standardausgabe auf Pipe-Schreibseite (Pipe-Eingang) legen und Pipe-Leseseite (Pipe-   Ausgang) schließen (wird nicht benötigt)
   dup2(fds[1], 1); // 1 = Standardausgabe
   close(fds[0]);
   write (1, text, strlen(text)+1);
}
else{
   if (fork() == 0) {
      // 2. Kindprozess, Pipe-Leseseite (Pipe-Ausgang) auf
      // Standardeingabe umlenken und Pipe-Schreibseite
      // (Pipe-Eingang) schließen
      dup2(fds[0], 0); // 0 = standardeingabe
      close(fds[1]);
      while (count = read(0, buffer, 4))
      {
         // Pipe in einer Schleife auslesen
         prozess Pipe
         buffer[count] = 0; // String terminieren
         printf(“%s“, buffer) // und ausgeben
      }
   else {
      // Im Vaterprozess: Pipe an beiden Seiten schließen und
      // auf das Beenden der Kindprozesse warten
      close(fds[0]);
      close[fds[1]);
      wait(&status);
      wait(&status);
   }
   exit(0);
}
\end{verbatim}