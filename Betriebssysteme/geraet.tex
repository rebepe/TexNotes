\section*{Geräte}
Blockorientiert(Festplatte) vs Zeichenorientiert(Maus)

Controller: steuert das Gerät, fehlerkorrektur, auslösen von interrupts, ...
Steuerung über spezielle Register, ansprechen durch spezielle Assemblerbefehle (selten), oder einblendung in den Adressraum des Treibers

Ziele:
• Geräteunabhängigkeit (abstraktion der Schnittstelle)
• Einheitliches Benennungsschema
• Fehlerbehandlung
• Synchrone vs. Asynchrone Übertragung
• Puffern
• Gemeinsam vs. exklusiv benutzbare Geräte

Programmierte Steuerung(Analog Busy Waiting), Interruptgesteuert(interrupt pro fertiger Aktion), DMA(interrupt wenn puffer abgearbeitet);

Die wichtigsten Aufgaben eines Treibers:
- Initialisierung und Bekanntgabe des Geräts
- Datenübertragung von und zu einem Gerät
- Logisches Programmiermodell auf gerätespezifische
Anforderungen übersetzen
- Pufferung von Daten
- Interruptbearbeitung
- Koordination der nebenläufigen Zugriffe

Treiber werden als Module vom Hersteller geschrieben und dynamisch (bei embedded auch statisch durch Compiler) geladen. Binden sich an Standardschnittstelle des Betriebssystems

\section*{Festplatten}
Low-level-formatieren: anlegen von Spuren,Sektoren,sektorlücken

Zylinderversatz: Spuren werden um die drehungsgeschwindigkeit*Wechseldauer Versatz gespeichert.

Interleaving: Sektoren nicht sequentiell sondern wechselnd gespeichert (wegen verzögerung durch Fehlerkorrektur,puffer,etc)

High-Level-Formatieren:
Anlegen von Partition (Boot-Block, Freibereichsliste, Wurzelverzeichnis, I-nodes ...)

Positionierungsstrategien: FCFS (First Come First Serve): in anfragereihenfolge,
SSF (Shortest Seek first): die am nächsten liegende Spur, Aufzugalgorithmus: alle in einer Richtung und anschließend die Anderen




\section*{schichten der E/A-Software}: Benutzerprozess, Geräteunabhängige Software, treiber, Unterbrechungsroutinen, Hardware 