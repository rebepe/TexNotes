\section*{Speicherverwaltung}
\textbf{Lokalitätsprinzip:} örtlich: nah beieinanderliegende Daten werden oft zusammen benötigt, zeitlich: Daten werden oft sofort wieder benutzt

\textbf{Adressraum:} benutzbare Adressen (z.B. $2^{32}$); Anordung durch Compiler (z.B.  
\fbox{Code}\fbox{Konstanten}\fbox{ Heap}\fbox{Stack)}

\subsection*{Cache}
write through (sofort) vs write back (bei auslagern) vs write on demand (erst durch expliziten Befehl)

\subsubsection*{Ersetzungsstrategien}
\begin{itemize}
\item LRU (Least Recently Used) ältester Zugriffszeitstempel
\item LFU (Least Frequently Used) Zähler, hochzählen pro zugriff, niedrigster wird zuerst ausgelagert;\\
mit altern: setzen auf 0 nach intervall
\item LRL (Least Recently Loaded) analog zu FIFO, ältester Einlagerunszeitstempel wird ausgelagert
\item Zufällige Seite wird ausgelagert; billig umzusetzen
\end{itemize}


\subsection*{Speicherverwaltung}
\begin{itemize}
\item Monoprogramming: Ein Programm hat gesamten RAM (bis auf BS)
\item feste Partitionierung: Aufteilen des RAM in feste Bereiche, Prozesse bekommt einen zugeteilt
\item Swapping: Prozesse werden im Ganzen ein/ausgelagert (Fragmentierung!)
\item Virtueller Speicher: Aufteilung des Adressraums in Seiten, diese werden ein/ausgelagert. => Adressraum kann größer sein als RAM.
\end{itemize}

\begin{tabular}[width=\textwidth]{|l|}
\hline
\textbf{Umrechnung durch MMU: }\\
$Adresse_{Virtuell}$ = Seite + \underline{Offset};\\
$Adresse_{Real}$ = Rahmen + \underline{Offset};\\
Seite $\Leftrightarrow$ Rahmen: Lookup in Seitentabelle \rule{0.25\textwidth}{0em} \\
\hline
\end{tabular}

Ein/Auslagern in \textbf{Paging Area} auf Festplatte;

Ggf. Caching durch \textbf{TLB} (Translation Lookaside Buffer); \\
TLB-Einträge beinhalten PID

\textbf{Page Fault:} Seite nicht im RAM -> Einlagern nötig

\textbf{Mehrstufige Adresstabellen:} die bitgruppen gibt den index in der entsprechenden Tabelle an, diese enthält die Nummer der nächsten Seitentabelle 

Bsp:$ \underbrace{001100}_{1.Level}\underbrace{110101}_{2.Level}\underbrace{1001010001}_{offset}$

\textbf{invertierte Seitentabelle:} eine Tabelle mit Zuordnung Rahmen->Seiten; aufwändigere Suche, weniger Speicherbedarf (Lookup über Hashtabelle)

\stopwashere

\subsection*{Ersetzungsstrategien}
Demand Paging: nach Page-Fault
\begin{itemize}
\item Belady (optimal): ersetzung der Seiten die am spätesten in der Zukunft wieder verwendet wird
\item FIFO: älteste Seite wird ersetzt, einfach zu implementieren (Verkettete Liste)
\item Second Chance: ähnlich FIFO; ist R-Bit gesetzt hänge hinten an und setze R=0, sonst auslagern
\item NRU (Not Recently Used): \textbf{R}ead-Bit \textbf{M}odified-Bit; Auslagerungsreihenfolge: R=0,M=0;~~~R=0,M=1;~~~R=1,M=0;~~~R=1,M=1
\item LRU (Least Recently Used) Am längsten nicht genutzt wird ausgelagert
\item NFU (Not Frequently Used) Zähler für Zugriffe, auslagerung des Eintrags mit kleinstem Zähler\\
Aging:
\begin{itemize}
	\item als Matrix: setze Bei Zugriff alle in Zeile auf 1, alle in spalte auf 0
	Bsp: $\left( \begin{matrix}
	0 &1 &0 \\
	0 & 0& 0\\
	1 & 1 & 0
	\end{matrix} \right), Zugriff auf 2 => \left( \begin{matrix}
	0 &0 &0 \\
	1 & 0& 1\\
	1 & 0 & 0	
	\end{matrix} \right)$
	\item als Register: shifte die R-Bits von links ein
	Bsp: $R \begin{matrix}
	1\\0\\1\\1\\0
	\end{matrix} Register: \begin{matrix}
	1001\\1010\\0011\\0001\\1101
	\end{matrix}   =>  \begin{matrix}
	1100\\0101\\1001\\1000\\0110
	\end{matrix}$
\end{itemize}
\end{itemize}

Prepaging: Working Set: aktuell Bearbeitete Seiten, versuch daraus die benötigten Seiten zu ermitteln; $\tau$ = Zeitraum für ein Workingset
Bsp: Working Set Clock: 
wenn R == 1
\{ R=0, nächste Seite; \}
sonst
\{ wenn Alter > $\tau$ und M == 0 überschreiben 
   wenn Alter > $\tau $ und M == 1 sichere die geänderte Seite, betrachte nächste seite
\}


Ist der Zeiger wieder am Anfang: wenn seite ausgelagert wurde laufe weiter bis zur nächsten sauberen Seite.
Wurde keine Seite ausgelagert: wähle Zufällige Seite (denn alle gehören zum Working Set)

\subsection*{Speicherbelegung}
Suche nach freien Speicherbereichen; 
\begin{itemize}
\item sequentielle Suche: erster Passender Bereich wird vergeben
\item optimale Suche: möglichst genau passender Bereich wird vergeben um Fragmentierung zu vermeiden
\item Buddy-Technik: schrittweises halbieren des Speichers => externe Fragmentierung sinkt, interne Steigt;
\end{itemize}

\subsection*{Cleaning}
\begin{itemize}
\item Demand-Cleaning: Bei Bedarf
\item Precleaning: Präventives Zurückschreiben, wenn Zeit ist
\item Page-Buffering: Verwaltung in Listen (Modified List, Unmodified List)
\end{itemize}

\section*{Dateiverwaltung}
Dateien: abstrahiert perisistente Speicherung

Dateien, Pseudodateien (Freiliste), Verzeichnisse, Gerätedateien ( abstraktion von geräten, z.B. /dev/sda)

Sequentieller vs Wahlfreier Zugriff

Metadaten: informtionen über die Datei (Zugriffsrechte, Erstelldatum, zugriffsdatum...)

Operationen:
create
• delete
• open
• close
• read
• write
• append
• seek
• get attributes
• set attributes
• rename

Memory-Mapping: einblenden der Datei in den Adressraum eines Prozesses


Master Boot Record auf Sektor 0, Partition Table, Bootblock, Superblock enthält Verwaltungsinformationen zum
Dateisystem (Anzahl der Blöcke,...), Free Blocks (z.B. Bitmap) gibt die freien Blöcke des
Dateisystems an, Rootverzeichnis enthält den Inhalt des Dateisystems, I-nodes;

Dateiimplementierung:
\begin{itemize}
\item Zusammenhängend => Fragmentierung
\item Verkettung der Blöcke => Langsam
\item Verkettet durch FAT im Arbeitsspeicher, hoher Platzbedarf
\item I-Node: enthält: Metadaten, direkte Blockverweise, verweise auf ein-, zwei und dreifach-Indirekte Blöcke
\end{itemize}

Finden einer Datei: suche Verzeichnis anhand Pfad, Verzeichnis enthält I-Node-nummer, bzw. Nummer des 1. Blocks

Hard-Link: Verzeichnisse zeigen auf den selben I-Node;
Symbolic Link: Datei vom Typ LINK enthält Pfad

Virtuelles Filesystem: abstraktionsschicht zwischen Systemaufrufen und Dateisystemen (Windows: Laufwerksbuchstabe, Linux: mounten im Verzeichnisbaum

Blockgröße: je größer desto bessere Datenrate, je kleiner desto Speichereffizienter

Freiblockverwaltung: Liste vs Bitmap

\subsection*{Konsistenzsicherung}
Blockebene:

Zähler vorkommen eines blocks in dateien vs Zähler Block in Freiliste
\begin{itemize}
\item Fehlender Block => einfügen in Freibereichsliste
\item Doppelt in Freibereich => Freibereich anpassen
\item 1x Frei 1x Belegt => Aus Freibereich entfernen
\item Belegt in 2 Dateien => Kopiere Block, ordne ihn einer der Dateien zu; ausgabe für den Benutzer
\end{itemize}

Dateiebene: Prüfe den Linkzähler aller Dateien und passe ihn an

sonstiges, z.B. unsinnige Zugriffsrechte, Dateien größe 0, etc.

\subsubsection*{Journaling}
Vor ausführen einer Aktion: Eintrag in Log; => Aktion kann nach absturz wiederholt werden.

\subsection*{Cache}
Puffern der Blöcke, zugriff über hash, auslagerungsstrategie meist LRU, angepasst nach heuristik;

Konsistenzrelevante Änderungen sofort rausschreiben, Write-Through oder regelmäßiges Rausschreiben von Änderungen sinnvoll

\subsection*{Flash}
wichtig: gleichmäßige Abnutzung => zurückschreiben nicht an selber stelle (Copy-on-write) => "wandering Trees"

Flash Translation Layer: Abbildung Dateisystemadresse auf Sektor

Virtual Block Map:  zuordnungstabelle im RAM, mehrstufig; 
Invertierte: jeder Sektor speichert seine Adresse, oder reservierter sektor pro bank enthält tabelle => scannen beim Mounten

Superblock: reservierte Bänke + Zeittempel, oder durchsuche gesamten Datenträger

löschen: informieren des Controllers mit TRIM-Kommando über gelöschte Blöcke, damit sie wiederverwendet werden können

Logging Dateisysteme: 
ähnlich Journaling, aber es werden nur die Änderungen geschrieben + Checkpoints; Garbage Collection\\
Vorteil: schnelleres Schreiben, passt zu Flash
Nachteil: (Fragmentierung), Garbage Collecting


\section*{NTFS}
Alles steht in MFT (Master-File-Table), Blöcke in Serien angegeben (von-anzahlBlöcke)
