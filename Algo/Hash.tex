\minpurp{Hashtabellen}
Speicherung in Tabelle, berechnung der Adresse durch Hashen eines Schlüssels \\
\textbf{m = Tabellenplätze}

%\minpurp{Hashfunktionen}
%(Geburtstagsparadoxon) = $\prod_{i=1}^{k-1}\left(1-\dfrac{i}{m}\right) = e^{-k(k-1)/2m}$

\minmeth{Multiplikation}
$h(s) \lfloor m \lbrace sc \rbrace \rfloor$ mit $ \lbrace x \rbrace  = x - \lfloor x \rfloor$;
optimal mit c = $0.5(1+\sqrt{5})$ 

Implementieren mit Shift-Operationen für $m = 2^p, p\leq wortbreite$\\
=> die p vordersten Bits des unteren Worts von $s\cdot c$ (low-Register)

\fbox{\halfpage{
Bsp: w=8, p=6, c=0.618=0.10011110, s= 4= 100\\
=> h(s) : 10011110*100 = 10 | \underline{011110}00 => h(4)= 30}}

\minmeth{Universelle Familien}
(theorie): Zufallsfunktion= Tabelle aller Zuordnungen Wert->Hash, zufällig gewählte Spalte als Hash-funktion;
Kollisionswahrscheinlichkeit: 1/m

Funktionsfamilie ist universelle Familie, wenn Kollisionswahrscheinlichkeit = 1/m

Bsp: Primzahl p, Tabellengröße $m \leq p$; Wähle $a,b \in \mathbb{Z}_p$\\
$h(x) = ((ax+b)+mod~ p )~ mod~ m$

Bsp: Primzahl p, $a=(a_1,\dots,a_r) \in \mathbb{Z}_p^r$, x als p-adische Entwicklung, $x \leq p^r-1$\\
$h_a( x_1, x_2, \dots ,x_r ) = \Sigma_{i_1}^r a_i x_i ~mod ~p$

\minpurp{Kollisionsbehandlung}
\minpurp{Verkettung mit Überlaufbereich}
Hashfunktionen liefern Adressen im Primärbereich, Tabelleneinträge enthalten Nachfolgeradresse im Überlaufbereich; Freie überlaufzellen bilden zusätzliche verkettung


Zugriffe bei erfolgreicher Suche: $<1+1/2B$, Zugriffe bei nicht erfolgreicher suche: $\leq 1+ B$

\textbf{Kollisionswahrscheinlichkeit Verkettung:} $p_i = \left( \begin{array}{c}n \\ i\end{array} \right) \left( \dfrac{1}{m} \right)^i \left( 1- \dfrac{1}{m} \right)^{n-i} $

=> Überlaufbereich = $n-m(1-p_0)$  =  Kollisionen (m= größe Primärbereich, n=Anzahl Elemente) 

Freie Plätze im Mittel:$ -(n - m - \text{Überlauf})   $


\minpurp{Offene Adressierung}
Bei Kollision wird ein anderer Platz in der Tabelle gesucht, anhand einer Sondierfolge (alle Plätze müssen in Folge $i(s)_j$ enthalten sein).

\minmeth{Einfügen}
Suche erste freie/gelöschte Zelle in Sondierfolge, füge ein;

\minmeth{Suchen}
Durchlaufe Sondierfolge, bis gefunden oder sicher nicht in Tabelle 

\minmeth{Löschen} Suche und markiere als gelöscht

n von m Zellen belegt, B= freieZellen/alleZellen \\
mittlere Länge Sondierfolge beim Suchen : $\dfrac{1}{B}ln\left(\dfrac{1}{1-B}\right)$
beim Einfügen: $1/1-B$

\minpurp{Lineares Sondieren}
Sondierfolge: direkt aufeinander folgende Tabelleneinträge ($i(s)_j=h(s)+j~mod~m$\\
Nachteil: Sondierfolgen verketten sich (Cluster)

mittlere Länge Sondierfolge beim Suchen : $\dfrac{1}{2}\left(\dfrac{1}{1+B}\right)$
beim Einfügen:  $\dfrac{1}{2}\left(1+\left(\dfrac{1}{1-B}\right)^2\right)$

\minpurp{Quadratisches Sondieren}
Tabellenplätze m = Primzahl; idealerweise m = 3 mod 4 \\
$i(s)_j = h(s) \pm j^2~mod~m$ (also 0,+1,-1,+4,-4,...) 

\minpurp{Doppelhashing}
$i(s)_j = h(s) + jh^*(s)~ mod~ m$, idealerweise wahl von h und h* unabhängig, m prim

%\143