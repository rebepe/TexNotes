\section*{Terminal - Einfache, wirtschaftlich sichere Unterschriften}
Motivation: PC ist kompromittiert

Stand der Technik:
TruPoSign: zeigt Komplexe Datenformate

ZTIC: USB-Stick mit SSL/Proxy, Bankspezifisch

Secoder: Class 3 Terminal

Wirtschaftlich sicher: Angreifer gewinnorientiert, nicht Vandale

Schutz finanziell relevanter Daten: extrahieren, Kunde verifiziert PlainText

Erweitertes FinTS: User Defined Signature: String + Signatur

Verifikation: Signatur vs Text, Text vs Transaktion

=> Keine Versionsupdates, string kann aus Umgebung kommen, wird verifiziert
=> Vereinfachte Signaturumgebung: string lesen, anzeigen, bestätigen und auf Karte signieren, zurückgeben

Nürnberger Sicherheitstrichter: Angriffsoberfläche verringern



\section*{Defence in Depth}
Feingranulare Zugriffskontrolle in der Datenbank anhand Projekt

Zugriffskontrolle anhand Kategorien (Teilnehmer, Pflegedienst, etc)

Problem: Kontrolle über ganze Anwendung verteilt.
=> schwierig(Vollständig, Korrekt, Verständnis)
=> von anderem Code abhängig

\subsection*{Ansatz} trennen von Code

Anforderungen: Zentrale Datenbank, keine Zusatzprogramme(WAF), geringe Änderungen im Programm

Zugriffsmodell anhand: eigener Daten, vergangene Aktionen, Regeln

Spalten u. Zeilen beschränken

Vom Datenbankinhalt abhängig



\subsection*{Befehlsaufbau}
Anchor TabA.TabAId = Ext

TabA -> TabB VIA TabB.TabAID 

TabB: Keyword (readonly ...)


\subsection*{Implementierung}

Parametrized Views => Abhängig von z.B. SessionID

(User Defined Functions, Query Rewriting, Oracle Virtual Private Database)

=> API um Session Parameter erweitern => Applikation ändern

=> Alternative: vor und nach der Appl. Nachrichten abfangen, zusammenhang herstellen => Query Rewriting
