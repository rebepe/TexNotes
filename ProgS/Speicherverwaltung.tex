\minpurp{Speicherverwaltung}
\minmeth{Lebensdauer}
\submeth{Global} unbegrenzt\\
\submeth{Stack} allokation/freigabe mit funktionsaufruf/rückgabe\\
\submeth{Heap} Anlegen: Blöcke mit längenangaben, verkettet, werden nach speicher durchsucht\\
=> explizite reservierung/freigabe (Bei fehlern: Memory Leak/dangling reference)

\minmeth{Zugriff} Symboltabelle (von Funktion/Struct) speichert offset

\minmeth{Alignment}
\submeth{primitive Typen} Adresse muss durch Größe teilbar sein (z.B. Pointer: x8-Adressen)\\
\submeth{Zusammengesetzte Typen (Struct)} Alignment vom größten Element; \\padding auf nächste Alignte größe, auch am ende (z.B. {int, bool} => x4) 

Struct/Class: Reihenfolge wird nicht verändert.

Frame: ggf. durch umordnen optimiert

\minmeth{Größen in Byte}
\begin{tabular}{|r|l|l|l|l|l|l|}
\hline
Sprache & bool & char & int & float & double & Pointer(x64) \\ 
\hline
C++ & 1&1 & 4 &4&8&8\\
\hline
C\# & 1&2 & 4 &4&8&8\\
\hline
Javascript & 1 &&&&8&8\\
\hline
\end{tabular}


 









\minmeth{RTTI}
Dynamischer Typ (u.a. Vererbung) => Zeiger auf Typobjekt im Deskriptor

Typobjekt: Virtual Table (Adressen der \textbf{virtuellen} Methoden)

In C\#/Java: zus.: Verweis auf Obertyp und andere Metadaten
