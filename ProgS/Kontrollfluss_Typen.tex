\minpurp{Typen}
\minmeth{Konversionen}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{$\Leftrightarrow$}\\
\hline
Explizit Conversion  & Implizit Conversion \\
Cast &/Typanpassung /Coercion  \\
\hline
Converting Cast:  & Non-converting Cast: \\
Bits werden umgerechnet & Bitmuster bleibt \\
\hline
Narrowing:  & Widening:  \\
keine Teilmenge (int->float)&Zieltyp ist umfassender\\
\hline
Checked Conversion:   &Unchecked Conversion:  \\
Prüfung zur Laufzeit, ggf. Exception &ohne Prüfung\\
\hline
\end{tabular}

%\minmeth{Enum vs Symbol}
%Enum: statische Typen;
%
%Symbole: dynamische Typen: werden nicht deklariert, bilden 1 Typ z.B. Symbol.for("Monday") in JS6


\minmeth{Arrays}
\submeth{Adressrechnung} a mit größe n1,n2,n3 \\
a[i1,i2,i3] =>  a[0] + (i1 * n2* n3 + i2* n3 + i3) * sizeof(type);

\submeth{Prüfen Adressgrenzen}
C\#: Deskriptor mit Längenangaben für jede Dimension

\minmeth{Iteratoren}
\submeth{Äußere Iteration}Foreach schleife: von außen über die Collection

\submeth{Innere Iteration} Collectionfunktion: Übergabe von Closure, ausführen für alle Elemente

\submeth{Generatoren}
Erzeugung von Iteratoren mit yield => nächster Einsprung erfolgt hinter dem letzten yield, kontext bleibt erhalten

\submeth{Tail-recursion} wenn rekursion letzter schritt, dann goto statt funktionsaufruf\\
Allgemein: Tail Call Optimization: funktionsaufruf als letzter schritt => kein neuer Stackframe sondern nur den eigenen anpassen.



\minmeth{Konstanten}
\submeth{Compilezeitkonstanten} feste Adressen / immediate Werte

\submeth{Laufzeitkonstanten} (readonly,final)

\submeth{Immutable Typen} bieten keine setter an, variablen können umverzeigert werden.

