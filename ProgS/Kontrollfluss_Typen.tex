\minpurp{Funktionen}
\submeth{Statische Kette} nichtlokale Variablen in darunterliegenden Stackframes, implementierung durch Pointer

\minmeth{Closure} wird bei übergabe/speichern von Funktion gebildet. (Lambda)\\ 
Besteht aus Funktionszeiger und zeiger auf Heap-Objekt mit den gefangenen Variablen\\
Löst upward Funarg problem(Verweis auf nicht mehr existierende stackframes)\\
Ggf. teil der statische kette

C\#: Func <T1,$\dots$, Result>, Action<T>, Predicate<T>, Lambda

Bsp:   Func<int,double> cast = i => 1.0 * i;


C++: 2 Varianten: 


capture-by-copy: gefangene Variablen werden kopiert: [\textbf{=}](int a) \{return a+4;\}

capture-by-reference: Closure erhält pointer auf variablen: [\textbf{\&}](int a) \{return a+4;\}

\minmeth{Parameterübergabe}
Call by Value: Wert wird kopiert  

\rule{1cm}{0pt}
\textit{methode (int)}

"Call by Sharing": Call by Value einer Pointervariable ( => Swap nicht möglich)

\rule{1cm}{0pt}\textit{methode (int*)}

Call by Reference: Zeiger auf übergebene Variable

\rule{1cm}{0pt}\textit{methode ( int \&)}

Call by const Reference (c++): analog Call by reference, verbot schreibzugriff

\rule{1cm}{0pt}\textit{methode (const int \&)}

Call by name: unausgewertete Übergabe durch implizite(explizite) Closures

\minmeth{Methoden}
\submeth{methoden}

C++/C\#:

statische Methoden werden zu normalen Funktionen aufgelöst, 

normale Methoden: Call-by-Reference von this als 1. Parameter

Virtuelle Methoden: zur Laufzeit über vptr/RTTI in der virtual Table gesucht;

Javascript: Suche der Methode in den Properties (Hashtable)

\minpurp{Konversionen}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{$\Leftrightarrow$}\\
\hline
Explizit Conversion  & Implizit Conversion \\
Cast &/Typanpassung /Coercion  \\
\hline
Converting Cast:  & Non-converting Cast: \\
Bits werden umgerechnet & Bitmuster bleibt \\
\hline
Narrowing:  & Widening:  \\
keine Teilmenge (int->float)&Zieltyp ist umfassender\\
\hline
Checked Conversion:   &Unchecked Conversion:  \\
Prüfung zur Laufzeit, ggf. Exception &ohne Prüfung\\
\hline
\end{tabular}

%\minpurp{Enum vs Symbol}
%Enum: statische Typen;
%
%Symbole: dynamische Typen: werden nicht deklariert, bilden 1 Typ z.B. Symbol.for("Monday") in JS6


\newpage
\minpurp{Arrays}
\submeth{Adressrechnung} a mit größe n1,n2,n3 \\
a[i1,i2,i3] =>  a[0] + (i1 * n2* n3 + i2* n3 + i3) * sizeof(type);

\submeth{Prüfen Adressgrenzen}
C\#: Deskriptor mit Längenangaben für jede Dimension

\minpurp{Iteration}
\submeth{Äußere Iteration}Foreach schleife: von außen über die Collection

\submeth{Innere Iteration} Collectionfunktion: Übergabe von Closure, ausführen für alle Elemente

\submeth{Generatoren}
Erzeugung von Iteratoren mit yield => nächster Einsprung erfolgt hinter dem letzten yield, kontext bleibt erhalten

\submeth{Tail-recursion} wenn rekursion letzter schritt, dann goto statt funktionsaufruf\\
Allgemein: Tail Call Optimization: funktionsaufruf als letzter schritt => kein neuer Stackframe sondern nur den eigenen anpassen.



\minpurp{Konstanten}
\submeth{Compilezeitkonstanten} feste Adressen / immediate Werte

\submeth{Laufzeitkonstanten} (readonly,final)

\submeth{Immutable Typen} bieten keine setter an, variablen können umverzeigert werden.

\minpurp{Exceptions}
Ersatz von Fehlercode-Rückgabewerten durch Exceptions;

Globale Tabellen ordnen Programmzählerbereiche entsprechenden Handlern zu; 

\submeth{Stack unwinding} Werfen einer Exception => Stack nach unten durchlaufen bis gehandelt


\minpurp{Referenztyp}
Typ der als Zeiger auf Heapobjekt implementiert ist.

\submeth{Mit Wertsemantik} ist immutable => kein Unterschied zum Werttyp feststellbar (z.B. C\# String)

