\minpurp{Kontrollfluss}

\minmeth{Iteratoren}
\submeth{Äußere Iteration}
Foreach schleife: von außen über die Collection
\submeth{Innere Iteration}
Map/Reduce Funktionen: Collection wendet Closure auf alle Elemente an

\submeth{Generatoren}
Erzeugung von Iteratoren mit yield => nächster Einsprung erfolgt hinter dem letzten yield, kontext bleibt erhalten
\minmeth{Schleife vs Rekursion}
optimierung: Tail-recursion: wenn rekursion letzter schritt, dann goto statt funktionsaufruf\\
Allgemein: Tail Call Optimization: funktionsaufruf als letzter schritt => kein neuer Stackframe sondern nur den eigenen anpassen.


\minpurp{Konversionen}


\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{$\Leftrightarrow$}\\
\hline
Explizit Conversion  & Implizit Conversion \\
Cast &/Typanpassung /Coercion  \\
\hline
Converting Cast:  & Non-converting Cast: \\
Bits werden umgerechnet & Bitmuster bleibt \\
\hline
Narrowing:  & Widening:  \\
keine Teilmenge (int->float)&Zieltyp ist umfassender\\
\hline
Checked Conversion:   &Unchecked Conversion:  \\
Prüfung zur Laufzeit, ggf. Exception &ohne Prüfung\\
\hline
\end{tabular}

\minpurp{Konversionen}


\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{$\Leftrightarrow$}\\
\hline
Explizit Conversion  & Implizit Conversion \\
Cast &/Typanpassung /Coercion  \\
\hline
Converting Cast:  & Non-converting Cast: \\
Bits werden umgerechnet & Bitmuster bleibt \\
\hline
Narrowing:  & Widening:  \\
keine Teilmenge (int->float)&Zieltyp ist umfassender\\
\hline
Checked Conversion:   &Unchecked Conversion:  \\
Prüfung zur Laufzeit, ggf. Exception &ohne Prüfung\\
\hline
\end{tabular}

\minpurp{Größen in Byte}
\begin{tabular}{|r|l|l|l|l|l|l|}
\hline
Sprache & bool & char & int & float & double & Pointer(x64) \\ 
\hline
C++ & 1&1 & 4 &4&8&8\\
\hline
C\# & 1&2 & 4 &4&8&8\\
\hline
Javascript & 1 &&&&8&8\\
\hline
\end{tabular}

\minpurp{Enum vs Symbol}
Enum: statische Typen;

Symbole: dynamische Typen: werden nicht deklariert, bilden 1 Typ z.B. Symbol.for("Monday") in JS6


\minmeth{Collections:}
\submeth{Arrays}
Adressrechnung: a mit größe n1,n2,n3 \\
a[i1,i2,i3] =>  a[0] + (i1 * n2* n3 + i2* n3 + i3) * sizeof(type);

Prüfen Adressgrenzen: 
C\#: neben RTTI wird Deskriptor mit Längenangaben für jede Dimension angelegt

\minmeth{Konstanten}
Compilezeitkonstanten: feste Adressen / immediate Werte

Laufzeitkonstanten: (readonly,final)

Immutable Typen: bieten keine setter an, variablen können umverzeigert werden.

