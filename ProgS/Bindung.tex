\minpurp{Bindungen}
Namensbindung, Typbindung, Wertbindung, Adressbindung

anonym vs Namensbindung

statisch (zur Kompilezeit in Symboltabelle) vs dynamische Bindung (zur Laufzeit im Speicher z.B. Werte, virtuelle Methoden)

\minpurp{scope}
lexikalischer Scope: bindung an den umgebenden Block.

freie Variablen: keine lokale bindung (nicht in diesem Block)
Funktionen sind Closures wenn alle freien Variablen nicht-lokal gebunden sind

\minpurp{Speicherverwaltung}
Lebensdauer: \\
Global: unbegrenzt\\
Stack: allokation/freigabe mit funktionsaufruf/rückgabe\\
Heap: explizite reservierung/freigabe (Bei fehlern: Memory Leak/dangling reference)

\minmeth{Stack}
Aufbau Stackframe(x64 Windows): geregelt im ABI (Application Binary Interface):

Aufruf erzeugt neuen Stackframe (groß genung für alle parameter) und lädt parameter. Aufbau:

\newcommand{\shadowspace}{\hline
Shadowspace\\
(8 Byte)\\}
\begin{tabular}{|c|}
\multicolumn{1}{l}{(16bit aligned):}\\
\shadowspace
\shadowspace
\shadowspace
\shadowspace
\hline
$\cdots$\\
Variablen (aligned)\\
ggf. Leerräume\\
$\cdots$ \\
\hline
Return Adress \\
(8 Byte)\\
\hline
\multicolumn{1}{l}{Nächster Frame,} \\
\multicolumn{1}{l}{Achtung x16 Alignment}
\end{tabular}
Parameterübergaberegister: RCX, RDX, R8, R9

Rückgaberegister: RAX 

Caller saved: RAX, RCX, RDX, R8, R9, R10, R11 \\
(werden potentiell vom Aufrufer überschrieben)

Callee preserved:(RIP), RBX, RBP, RDI, RSI, RSP, R12...R15 \\
(müssen vom Unterprogram gesichert(im Prolog) und restauriert(im Epilog) werden

\minmeth{Heap}
Blöcke mit längenangaben, verkettet, werden nach ausreichend speicher durchsucht

\minmeth{Umgebung bei lokalen Funktionen}
\submeth{Statische Kette:} nichtlokale Variablen in darunterliegenden Stackframes, verfolgen von entsprechenden Pointern

\submeth{Closure:} wird bei übergabe/speichern von Funktion gebildet. Besteht aus Funktionszeiger und zeiger auf Heap-Objekt mit den gefangenen Variablen
Löst upward Funarg problem(Verweis auf nicht mehr existierende stackframes)
Bilden auch statische kette


